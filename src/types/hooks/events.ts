/**
 * Hook event types for Claude Code
 * Based on: https://code.claude.com/docs/en/hooks.md
 *
 * This module provides input/output types for all hook events:
 * - PreToolUse/PostToolUse (tool execution hooks)
 * - SessionStart/SessionEnd (session lifecycle)
 * - SubagentStart/SubagentStop (subagent lifecycle)
 * - UserPromptSubmit (user input)
 * - Notification (system notifications)
 * - Stop (execution control)
 * - PreCompact (context management)
 */

import type { BaseHookInput, BaseHookOutput } from './base.js';
import type {
  KnownToolName,
  ToolInputMap,
  SystemToolInput,
  SystemToolWithResponse
} from '../tools/system.js';
import type {
  McpToolInputUnion,
  McpToolWithResponseUnion
} from '../mcp/index.js';

// ============================================================================
// PreToolUse Hook
// ============================================================================

/**
 * PreToolUse hook input - discriminated union of all possible tool inputs
 * Uses SystemToolInput for system tools and McpToolInputUnion for MCP tools.
 *
 * MCP tool types are auto-generated by `cck-sync-mcp` and provide typed
 * access to tool_input for synced MCP servers. Unsynced MCP tools fall
 * back to `unknown` for tool_input.
 */
export type PreToolUseInput =
  | (BaseHookInput & SystemToolInput & { hook_event_name: "PreToolUse"; tool_use_id: string })
  | McpToolInputUnion;

/**
 * PreToolUse hook output with type-safe updatedInput
 *
 * The updatedInput field is type-safe based on the tool being used.
 * - For known tools: updatedInput is Partial<ToolInput>
 * - For unknown MCP tools: updatedInput is Record<string, unknown>
 */
export type PreToolUseHookOutput<TInput extends PreToolUseInput = PreToolUseInput> =
  BaseHookOutput & {
    hookSpecificOutput:
      | {
          hookEventName: "PreToolUse";
          permissionDecision: "allow";
          /** When permissionDecision is "allow", shows to user only */
          permissionDecisionReason?: string;
          /** Modify tool input parameters before execution.
           * Type-safe for known tools, Record<string, unknown> for unknown MCP tools.
           */
          updatedInput?: TInput extends { tool_name: infer TName }
            ? TName extends KnownToolName
              ? Partial<ToolInputMap[TName]>
              : TName extends string
                ? Record<string, unknown>
                : never
            : never;
        }
      | {
          hookEventName: "PreToolUse";
          /** "ask" will request user approval */
          permissionDecision: "deny" | "ask";
          /** Required for "deny" or "ask". For "ask" shows to user; for "deny" shows to Claude only */
          permissionDecisionReason: string;
        };
  };

/**
 * PreToolUse hook function type
 *
 * Called before any tool (system or MCP) is executed.
 * Can allow, deny, or ask for permission, and optionally modify tool inputs.
 *
 * @example
 * const hook: PreToolUseHook = (input) => {
 *   return {
 *     hookSpecificOutput: {
 *       hookEventName: 'PreToolUse',
 *       permissionDecision: 'allow',
 *     },
 *   };
 * };
 * export default hook;
 */
export type PreToolUseHook = (
  input: PreToolUseInput
) => PreToolUseHookOutput | Promise<PreToolUseHookOutput>;

// ============================================================================
// PostToolUse Hook
// ============================================================================

/**
 * PostToolUse hook input - discriminated union of all possible tool inputs
 * Uses SystemToolWithResponse for system tools and McpToolWithResponseUnion for MCP tools.
 *
 * MCP tool types are auto-generated by `cck-sync-mcp` and provide typed
 * access to tool_input and tool_response for synced MCP servers.
 */
export type PostToolUseInput =
  | (BaseHookInput & SystemToolWithResponse & { hook_event_name: "PostToolUse"; tool_use_id: string })
  | McpToolWithResponseUnion;

/**
 * PostToolUse hook output
 */
export type PostToolUseHookOutput = BaseHookOutput &
  (
    | {
        decision: undefined;
        reason?: string;
        hookSpecificOutput?: {
          hookEventName: "PostToolUse";
          additionalContext?: string;
        };
      }
    | {
        decision: "block";
        reason?: string;
        /** Required when decision is "block" */
        hookSpecificOutput: {
          hookEventName: "PostToolUse";
          /** Required when decision is "block" */
          additionalContext: string;
        };
      }
  );

/**
 * PostToolUse hook function type
 *
 * Called after any tool (system or MCP) has been executed.
 * Can block the result or provide additional context to Claude.
 *
 * @example
 * const hook: PostToolUseHook = (input) => {
 *   return {
 *     hookSpecificOutput: {
 *       hookEventName: 'PostToolUse',
 *       additionalContext: 'Some context for Claude',
 *     },
 *   };
 * };
 * export default hook;
 */
export type PostToolUseHook = (
  input: PostToolUseInput
) => PostToolUseHookOutput | Promise<PostToolUseHookOutput>;

// ============================================================================
// SessionStart Hook
// ============================================================================

type SessionStartSource = "startup" | "resume" | "clear" | "compact";

export interface SessionStartInput extends BaseHookInput {
  hook_event_name: "SessionStart";
  source: SessionStartSource;
}

export interface SessionStartHookOutput extends BaseHookOutput {
  hookSpecificOutput: {
    hookEventName: "SessionStart";
    additionalContext: string;
  };
}

/**
 * SessionStart hook function type
 *
 * @example
 * const hook: SessionStartHook = (input) => {
 *   return {
 *     hookSpecificOutput: {
 *       hookEventName: 'SessionStart',
 *       additionalContext: 'Context for Claude',
 *     },
 *   };
 * };
 * export default hook;
 */
export type SessionStartHook = (
  input: SessionStartInput
) => SessionStartHookOutput | Promise<SessionStartHookOutput>;

// ============================================================================
// SessionEnd Hook
// ============================================================================

type SessionEndReason = "clear" | "logout" | "prompt_input_exit" | "other";

export interface SessionEndInput extends BaseHookInput {
  hook_event_name: "SessionEnd";
  reason: SessionEndReason;
}

export type SessionEndHookOutput = BaseHookOutput;

/**
 * SessionEnd hook function type
 */
export type SessionEndHook = (
  input: SessionEndInput
) => SessionEndHookOutput | Promise<SessionEndHookOutput>;

// ============================================================================
// SubagentStart Hook
// ============================================================================

export interface SubagentStartInput extends BaseHookInput {
  hook_event_name: "SubagentStart";
  /** Agent identifier (lowercase letters and numbers) */
  agent_id: string;
  /** Type of agent being started */
  agent_type: string;
}

export interface SubagentStartHookOutput extends BaseHookOutput {
  hookSpecificOutput?: {
    hookEventName: "SubagentStart";
  };
}

/**
 * SubagentStart hook function type
 */
export type SubagentStartHook = (
  input: SubagentStartInput
) => SubagentStartHookOutput | Promise<SubagentStartHookOutput>;

// ============================================================================
// SubagentStop Hook
// ============================================================================

export interface SubagentStopInput extends BaseHookInput {
  hook_event_name: "SubagentStop";
  stop_hook_active: boolean;
  /** Agent identifier (lowercase letters and numbers) */
  agent_id: string;
  /** Path to the agent's transcript file */
  agent_transcript_path: string;
}

export interface SubagentStopHookOutput extends BaseHookOutput {
  decision?: "block";
  reason?: string;
}

/**
 * SubagentStop hook function type
 */
export type SubagentStopHook = (
  input: SubagentStopInput
) => SubagentStopHookOutput | Promise<SubagentStopHookOutput>;

// ============================================================================
// Notification Hook
// ============================================================================

export interface NotificationInput extends BaseHookInput {
  hook_event_name: "Notification";
  message: string;
}

/**
 * Notification hook output
 */
export type NotificationHookOutput = BaseHookOutput;

/**
 * Notification hook function type
 */
export type NotificationHook = (
  input: NotificationInput
) => NotificationHookOutput | Promise<NotificationHookOutput>;

// ============================================================================
// UserPromptSubmit Hook
// ============================================================================

export interface UserPromptSubmitInput extends BaseHookInput {
  hook_event_name: "UserPromptSubmit";
  prompt: string;
}

export type UserPromptSubmitHookOutput = BaseHookOutput &
  (
    | {
        decision?: undefined;
        reason?: string;
        hookSpecificOutput?: {
          hookEventName: "UserPromptSubmit";
          additionalContext?: string;
        };
      }
    | {
        decision: "block";
        reason?: string;
        /** Required when decision is "block" */
        hookSpecificOutput: {
          hookEventName: "UserPromptSubmit";
          /** Required when decision is "block" */
          additionalContext: string;
        };
      }
  );

/**
 * UserPromptSubmit hook function type
 */
export type UserPromptSubmitHook = (
  input: UserPromptSubmitInput
) => UserPromptSubmitHookOutput | Promise<UserPromptSubmitHookOutput>;

// ============================================================================
// Stop Hook
// ============================================================================

export interface StopInput extends BaseHookInput {
  hook_event_name: "Stop";
  stop_hook_active: boolean;
}

export interface StopHookOutput extends BaseHookOutput {
  decision?: "block";
  reason?: string;
}

/**
 * Stop hook function type
 */
export type StopHook = (
  input: StopInput
) => StopHookOutput | Promise<StopHookOutput>;

// ============================================================================
// PreCompact Hook
// ============================================================================

type PreCompactTrigger = "manual" | "auto";

export interface PreCompactInput extends BaseHookInput {
  hook_event_name: "PreCompact";
  trigger: PreCompactTrigger;
  custom_instructions: string;
}

/**
 * PreCompact hook output
 */
export type PreCompactHookOutput = BaseHookOutput;

/**
 * PreCompact hook function type
 */
export type PreCompactHook = (
  input: PreCompactInput
) => PreCompactHookOutput | Promise<PreCompactHookOutput>;

// ============================================================================
// PermissionRequest Hook
// ============================================================================

/**
 * PermissionRequest hook output
 *
 * Note: PermissionRequest has no input type as it's triggered internally by Claude Code.
 * This hook fires when Claude requests permission for an action that requires user approval.
 *
 * Note on updatedInput:
 * - Only available when behavior is "allow"
 * - Should contain fields matching the tool's input type
 * - TypeScript uses Record<string, unknown> as the exact type depends on the tool
 * - Runtime validation by Claude Code ensures the fields match the tool's input schema
 */
export interface PermissionRequestHookOutput extends BaseHookOutput {
  hookSpecificOutput: {
    hookEventName: "PermissionRequest";
    decision:
      | {
          behavior: "allow";
          /** Optional message explaining the decision */
          message?: string;
          /** Modify tool input parameters before execution */
          updatedInput?: Record<string, unknown>;
        }
      | {
          behavior: "deny";
          /** Required message explaining why permission was denied (shown to Claude) */
          message: string;
          /** Stop Claude execution when denying */
          interrupt?: boolean;
        };
  };
}
